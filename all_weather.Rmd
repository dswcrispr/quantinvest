---
title: "All weather & Global dynamic asset allocation 전략"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = F, warning = F)

```

레이달리오의 all weather 포트폴리오 전략과 Global dynamic asset allocation 전략에 대한 벡테스트 결과를 비교 벡테스팅 방법 및 코드는 https://github.com/hyunyulhenry/GDAA 을 참조


### 레이달리오의 all weather 포트폴리오

인플레이션, 저성장 등의 가능한 경제상황에 대체로 대응할 수 있게 고안된 포트폴리오. 
미 전체 주식 종목에 대한 ETF 30%, 미 장기채 ETF 40%, 미 중기채 ETF 15%, 금 ETF 7.5%, 원자재 ETF 7.5%로 구성되며 리밸런싱은 매년 수행

   
```{r settings, include = F}
pkg = c('httr', 'rvest', 'readr', 'stringr', 'dplyr', 'ggplot2', 'quantmod', 'dygraphs',
        'highcharter', 'plotly', 'PerformanceAnalytics', 'magrittr', 'corrplot', 'tidyr',
        'nloptr', 'quadprog', 'RiskPortfolios', 'timeSeries', 'lubridate','knitr', 'showtext',
        'corrplot')
sapply(pkg, require, character.only = T)

options(warn = -1)

font_add_google('Nanum Gothic', 'nanumgothic')
showtext_auto()
```


#### ETF 가격정보 다운로드 및 데이터 정리 
```{r download}
ticker = c('VTI', # 미국 상장 주식 전체(시가 가중평균)
           'TLT', # 미국 장기 국채
           'IEF', # 미국 중기 국채
           'GLD', # 금
           'DBC' # 원자재
           
)
getSymbols(ticker, src = 'yahoo')

# 수정 주가만 뽑아서 묶기
prices = do.call(cbind, lapply(ticker, function(x) Ad(get(x)))) %>% setNames(ticker)

# 일별 수익률 계산
rets = Return.calculate(prices) %>% na.omit() %>% window(., start = '2008-01-02')
```

#### 자산별 상관관계 
```{r corplot}
cor(rets) %>% corrplot(method = 'color', type = 'upper',
                       addCoef.col = 'black', number.cex = 0.7,
                       tl.cex = 0.6, tl.srt = 45, tl.col = 'black',
                       col = colorRampPalette(c('blue', 'white', 'red'))(200),
                       mar = c(0, 0, 0.5, 0))
```


#### Return.portfolio 함수를 통한 백테스트 
```{r backtesting}
portfolio_all_g = Return.portfolio(R = rets, weights = c(0.3, 0.4, 0.15, 0.075, 0.075),
                                   rebalance_on = 'years', verbose = T)

# 회전율 계산
Port_all_turnover = xts(rowSums(abs(portfolio_all_g$BOP.Weight - 
                                  stats::lag(portfolio_all_g$EOP.Weight)),
                                  na.rm = T), order.by = index(portfolio_all_g$BOP.Weight))

# 매 거래시 수수료가 0.3%라 가정
fee = 0.003

# 수익률을 반영한 순수익 계산
Port_all_net = portfolio_all_g$returns - (Port_all_turnover * fee)

names(Port_all_net) = 'Returns_allweather'
```

#### 백테스트 결과 
```{r result, echo = F}
# 누적 수익률을 차트로 표현 
chart.CumReturns(Port_all_net, main = '누적 수익률(all weather)', family = 'nanumgothic')
```


```{r result_1, echo = F}
# 누적 수익률 계산
누적수익률 = as.numeric(t(Return.cumulative(Port_all_net)))

# 연율화 수익률(산술평균) 계산
연평균수익률 = as.numeric(t(Return.annualized(Port_all_net, geometric = F)))

# 최대 낙푹(Max Drawdown) 계산
최대낙폭 = maxDrawdown(Port_all_net) 

# 연율화 변동성 계산
연평균표준편차 = as.numeric(t(StdDev.annualized(Port_all_net)))

# 테이블 생성 
table = data.frame(cbind(연평균수익률, 누적수익률, 최대낙폭, 연평균표준편차)) 
rownames(table) = c('All Weather')
```

```{r chart, echo = F}
# 연도별 수익률 그래프로 나타내기
R.yr = apply.yearly(Port_all_net, Return.cumulative) %>% 
  fortify.zoo() %>% mutate(Index = year(Index)) %>% 
  gather(key, value, -Index) %>% 
  mutate(key = factor(key, levels = unique(key)))

ggplot(R.yr, aes(x = Index, y = value)) +
  geom_bar(position = 'dodge', stat = 'identity') +
  ggtitle('연도별 수익률(all weather') +
  xlab(NULL) + ylab(NULL) +
  theme_bw() +
  scale_y_continuous(expand = c(0.03, 0.03)) +
  scale_x_continuous(breaks = R.yr$Index, expand = c(0.01, 0.01)) +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
        legend.position = 'bottom',
        legend.title = element_blank(),
        legend.text = element_text(size = 7),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        panel.grid.minor.x = element_blank() ) +
  guides(fill = guide_legend(byrow = T)) +
  geom_text(aes(label = paste(round(value*100, 2), '%'), 
                vjust = ifelse(value >= 0, -0.5, 1.5)),
            position = position_dodge(width = 1),
            size = 3)
```


#### 결과 요약(All weather)
```{r table, echo = F}
kable(table[1, ], caption = '결과 요약')
```

### GDAA(Global Dynamic Asset Allocation) 전략을 통한 포트폴리오

아래와 같은 방식으로 포트폴리오를 구성 

1. 글로벌 10개 자산 etf 중 과거 3~12개월 수익률이 높은 5개 etf를 선택

2. 개별 투자비중은 최소 10%, 최대 30% 제약 조건을 두고 최소분산 포트폴리오를 구성 

3. 매월 리밸런싱 실시

#### ETF 가격정보 다운로드 및 데이터 정리 
```{r pricedownload}
ticker = c('VTI', # 미국 상장 주식 전체(시가 가중평균)
           'IEV', # 유럽 주식
           'EWJ', # 일본 주식
           'EEM', # 이머징 주식
           'TLT', # 미국 장기 국채
           'IEF', # 미국 중기 국채
           'IYR', # 미국 리츠
           'RWX', # 글로벌 리츠
           'GLD', # 금
           'DBC' # 원자재
)

getSymbols(ticker, src = 'yahoo')

# 수정 주가만 뽑아서 묶기
prices = do.call(cbind, lapply(ticker, function(x) Ad(get(x)))) %>% setNames(ticker)

# 일별 수익률 계산
rets = Return.calculate(prices) %>% na.omit()
```

#### 자산별 상관관계 
```{r corplot1}
cor(rets) %>% corrplot(method = 'color', type = 'upper',
                       addCoef.col = 'black', number.cex = 0.7,
                       tl.cex = 0.6, tl.srt = 45, tl.col = 'black',
                       col = colorRampPalette(c('blue', 'white', 'red'))(200),
                       mar = c(0, 0, 0.5, 0))
```


#### 포트폴리오 구성
```{r create_port}
# 매월 말일 위치 구하기(리밸런싱 주기가 매월이므로)
ep = endpoints(rets, on = 'months')

# 매월 투자비중을 저장할 빈 리스트 생성
weights = list()

# lookback기간을 12개월로 설정
lookback = 12

# 초기 투자비중 값을 0으로 설정
wt_zero = rep(0, 10) %>% setNames(colnames(rets))

# 과거의 매월 말일 시점마다 포트폴리오의 비중을 구하는 코드
for (i in (lookback + 1) : length(ep)) {
  
  # 과거 3~12 개월 자료를 이용하여 모멘텀 계산(직전 과거 3~12개월간 누적수익률 각각구한 뒤 순위를 매김) 
  sub_ret = lapply(3 : 12, function(x) {
    scale(rank(Return.cumulative(rets[c(ep[i - x] : ep[i]), ] )))
  })
    
  # 수익률이 좋은 5개의 자산 추리기, rank함수는 숫자가 낮은것에서부터 순위를 매김
  K = (rank(- apply(do.call(cbind, sub_ret), 1, sum), ties.method = 'first') <= 5)
  
  # 수익률 좋은 5개 자산에 대한 공분산 행렬 생성 
  covmat = cov(rets[c(ep[i - 12] : ep[i]), K])
  
  wt = wt_zero
  
  # 최소 비중이 10% 최대 비중이 30%인 제약 하에서 최소 분산 포트폴리오 투자비중 구하기
  wt[K] = optimalPortfolio(covmat, control = list(type = 'minvol', 
                                                  constraint = 'user',
                                                  LB = rep(0.10, 5),
                                                  UB = rep(0.30, 5)))
  
  # 각 시점별 계산된 투자비중을 weights 리스트에 저장
  weights[[i]] = xts(t(wt), order.by = index(rets[ep[i]]))
}

weights = do.call(rbind, weights)

```

#### Return.portfolio 함수를 통한 백테스트 
```{r backtesting_gdaa}
portfolio_gdaa_g = Return.portfolio(R = rets, weights,
                             rebalance_on = 'months',
                             verbose = T)

# 회전율 계산
Port_gdaa_turnover = xts(rowSums(abs(portfolio_gdaa_g$BOP.Weight - 
                                       stats::lag(portfolio_gdaa_g$EOP.Weight)),
                            na.rm = T), order.by = index(portfolio_gdaa_g$BOP.Weight))

# 매 거래시 수수료가 0.3%라 가정
fee = 0.003

# 수익률을 반영한 순수익 계산
Port_gdaa_net = portfolio_gdaa_g$returns - (Port_gdaa_turnover * fee)

names(Port_gdaa_net) = 'Returns_gdaa'
```

#### 백테스트 결과 
```{r result_gdaa, echo = F}
# 누적 수익률을 차트로 표현 
chart.CumReturns(Port_gdaa_net, main = '누적 수익률(gdaa)', family = 'nanumgothic')
```


```{r result_1_gdaa, echo = F}
# 누적 수익률 계산
누적수익률 = as.numeric(t(Return.cumulative(Port_gdaa_net)))

# 연율화 수익률(산술평균) 계산
연평균수익률 = as.numeric(t(Return.annualized(Port_gdaa_net, geometric = F)))

# 최대 낙푹(Max Drawdown) 계산
최대낙폭 = maxDrawdown(Port_gdaa_net) 

# 연율화 변동성 계산
연평균표준편차 = as.numeric(t(StdDev.annualized(Port_gdaa_net)))

# 테이블 생성 
table = data.frame(cbind(연평균수익률, 누적수익률, 최대낙폭, 연평균표준편차)) 
rownames(table) = c('GDAA')
```

```{r chart_gdaa, echo = F}
# 연도별 수익률 그래프로 나타내기
R.yr = apply.yearly(Port_gdaa_net, Return.cumulative) %>% 
  fortify.zoo() %>% mutate(Index = year(Index)) %>% 
  gather(key, value, -Index) %>% 
  mutate(key = factor(key, levels = unique(key)))

ggplot(R.yr, aes(x = Index, y = value)) +
  geom_bar(position = 'dodge', stat = 'identity') +
  ggtitle('연도별 수익률(gdaa)') +
  xlab(NULL) + ylab(NULL) +
  theme_bw() +
  scale_y_continuous(expand = c(0.03, 0.03)) +
  scale_x_continuous(breaks = R.yr$Index, expand = c(0.01, 0.01)) +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
        legend.position = 'bottom',
        legend.title = element_blank(),
        legend.text = element_text(size = 7),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        panel.grid.minor.x = element_blank() ) +
  guides(fill = guide_legend(byrow = T)) +
  geom_text(aes(label = paste(round(value*100, 2), '%'), 
                vjust = ifelse(value >= 0, -0.5, 1.5)),
            position = position_dodge(width = 1),
            size = 3)
```


#### 결과 요약(GDAA)
```{r table_gdaa, echo = F}
kable(table[1, ], caption = '결과 요약')
```

### All weather vs GDAA

레이 달리오의 All Weather 포트폴리오와 GDAA 전략을 통한 포트폴리오의 결과를 비교

```{r compare}
portfolios = na.omit(cbind(Port_all_net, Port_gdaa_net)) %>% setNames(c('All weather', 'GDAA'))

charts.PerformanceSummary(portfolios, main = 'All weather vs GDAA')
```

#### 결과 요약(All Weather vs GDAA)
```{r table_gdaavs, echo = F}
누적수익률 = c(as.numeric(t(Return.cumulative(Port_all_net))),
                     as.numeric(t(Return.cumulative(Port_gdaa_net))))

연평균수익률 = c(as.numeric(t(Return.annualized(Port_all_net, geometric = F))),
           as.numeric(t(Return.annualized(Port_gdaa_net, geometric = F))))

최대낙폭 = c(maxDrawdown(Port_all_net), maxDrawdown(Port_gdaa_net)) 

연평균표준편차 = c(as.numeric(t(StdDev.annualized(Port_all_net))),
            as.numeric(t(StdDev.annualized(Port_gdaa_net))))

# 테이블 생성 
table = data.frame(cbind(연평균수익률, 누적수익률, 최대낙폭, 연평균표준편차)) 
rownames(table) = c('All Weather', 'GDAA')

kable(table[1:2, ], caption = '결과 요약')
```


